<!doctype html>
<html>
<head>
<title>Kaze - 風</title>
<style type="text/css">
pre {
  background-color: #ddd;
  border-width: 1px;
  border-color: #ccc #ccc #aaa;
  border-style: solid;
  color: #000;
  padding: .73em;
}
</style>
</head>
<body>
<h1>Kaze - 風</h1>
<p>A lightweight and nimble test runner.  Kaze translates to "wind" in Japanese.</p>

<ul>
  <li>Non-blocking, processing occurs within multiple 50 ms time slices</li>
  <li>Asynchronous, assertions may delegate their return value to another function executing in the future</li>
  <li>Benchmarking, compare speed between multiple tests using repetitive execution</li>
  <li>Regular expression filtering of test names allows easy running of test subsets</li>
  <li>Lightweight ~1.4 KB minified, ~700 B gzipped</li>
</ul>

<h2>Interface</h2>
<pre>
object kaze

  void clear();
  void pause();
  void resume();
  void run([Function onresult[, RegExp filter[, Number iterations]]]);
  void test(String name, Function assert);
  void tests(Object defs)
</pre>

<h2>Defining tests</h2>

<p>Test definitions consist of a name and an assertion function. Use a naming
pattern for test names to take advantage of runtime filtering. The return value
of the assertion method, caste to a boolean, determines if the assertion passes
or fails. Truish return values pass, while falsey return values fail.</p>

<p>Test assertions execute in the global scope. A single argument is supplied
which delegates the assertion's return value to another function executing in
the future.</p>

<h3>Synchronous assertions</h3>

<p>Simple tests return a result value directly from the assertion function.</p>

<pre>
kaze.test("ex:sync", function (del) {
  return [1,2,3].length == 3;
});
</pre>

<h3>Asynchronous assertions</h3>

<p>Testing an asynchronous subject requires the assertion to delegate its return
value to another function.  Common examples requiring asynchronous handling
include animations and ajax transactions.</p>

<p>Kaze provides a single <code>Function</code> argument to each assertion
method, called <code>del</code> in the examples below. Passing a function to
<code>del</code> returns the passed function wrapped as a delegated assertion
(delegate). The return value of the original assertion is ignored in favor of
the delegate's return value.</p>

<p>Delegates must execute within 5000 milliseconds from their time of creation.
<code>del</code> accepts an optional second argument which can be used to alter
this duration. A delegate which does not execute is failed and further test
running resumes. Any return values generated by an expired delegate are
ignored.</p>

<pre>
function del (Function assert[, Number msec]);
</pre>

<pre>
kaze.test("ex:async", function (del) {
  var start = +new Date;
  setTimeout(del(function () {
    return +new Date > start;
  }), 2000);
});
</pre>

<h3>Organization tactics</h3>

<p>The tests in the previous examples could have also been defined in a single
object then defined en-masse using <code>kaze.tests</code>. Defining
tests in objects and grouping similar tests into separate files usually benefits
organization. Using a consistent naming pattern will also help when specifying
which groups of tests should run.</p>

<pre>
// assert bodies omitted
var defs = {
  "ex:sync": function () {},
  "ex:async": function () {}
};

kaze.tests(defs);
</pre>

<h2>Executing tests</h2>

<p>Kaze's test running behavior can be manipulated to run all defined tests, or
a subset, as many times as necessary. An optional callback function is invoked
after each test has completed.</p>

<p>The <code>run()</code> method can be invoked before an earlier run task has
completed. Kaze will queue the arguments in a task stack then execute them after
completing pending tasks.</p>

<h3>Gathering test results</h3>

<pre>
function onresult
    String name
    Boolean pass
    Number elapse
    Number loops
    Number remaining
</pre>

<p>The first argument provided to <code>run</code> is a function matching the
signature above. This function will be invoked each time a test has completed. A
basic result handler may work like this:</p>

<pre>
// Define a simple test
kaze.test("ex:onresult", function () { return true; });

// Run the test and alert() the result
kaze.run(function (name, pass, elapsed, loops, remaining) {
  var msg = pass ? "PASS:" : "FAIL:" + name +
            " finished " + loops + " loops(s) in " + elapsed + " ms";

  // PASS: ex:onresult finished 1 loop(s) in 1 ms
  alert(msg);

  // No more tests remaining in this task
  if (!remaining) {
    alert("Tests complete");
  }
});
</pre>

<h3>Name filtering</h3>

<p>Running groups of one or more tests is accomplished using the optional filter
regular expression argument passed to <code>run</code>. The filter is run
against the name of each test. Only tests with names which match the filter will
be run. Tests can be easily included or excluded from running using this
approach.</p>

<pre>
// Assert bodies omitted for example
kaze.test("array.flatten", function () {});
kaze.test("node.remove", function () {});

// Run all tests that begin with "node" -- runs node.remove
kaze.run(function () {}, /^node/);

// Or, run all tests that DON'T start with "node" -- runs array.flatten
kaze.run(function () {}, /^(?!node)/);
</pre>

<h3>Repeated execution</h3>

<p>Running tests more than once is particularly useful to compare performance of
two or more tests.  Pass a number as the third argument to <code>run</code>
instructs Kaze to run each test that number of times.  The <code>onresult</code>
callback will be executed once after all iterations have completed.  The <code>pass</code>
argument supplied to <code>onresults</code> will only be <code>true</code> when
all iterations passed.</p>

<p>Kaze gracefully yields long running tests, allowing the browser to execute
pending scripts and update the UI.</p>

<pre>
// Which is faster, array.push or array[array.length]?

kaze.test("array.push", function () {
  var arr = [],
      iter = 1000;
  while (iter--) arr.push({});

  // Return value is unimportant
  return true;
});

kaze.test("array[array.length]", function () {
  var arr = [],
      iter = 1000;
  while (iter--) arr[arr.length] = {};

  // Return value is unimportant
  return true;
});

// This example buffers messages until all tests have finished
var messages = [],
    onresult = function (name, pass, elapsed, loops, remaining) {
      messages.push(name + ": " + elapsed);
      if (!remaining) {
        alert(messages.join("\n"));
      }
    };

// Run each test 100 times, use no custom filter
kaze.run(onresult, null, 100);
</pre>

<h3>Manipulating task processing</h3>

<p>General purpose execution controls are provided to pause and resume test
processing, as well as clearing queues containing pending tasks
(<code>run()</code> arguments) and test definitions.</p>

<p>The <code>pause()</code> and <code>resume()</code> methods are useful to
control test execution from a result handler or host environment. Kaze will not
execute tests nor tasks while paused. Calling <code>resume()</code> will
continue test and task processing.</p>

<p>Kaze's queues tests and tasks, executing each in the order called. The task
queue is depleted as each task is executed. While the test queue remains
available across tasks. Invoking <code>clear()</code> will empty both queues;
setting Kaze back to an empty state.</p>

<h2>Integration</h2>

<p>Kaze defines only a single global object. This object, and its methods, can
be renamed, deleted, or merged into other objects.</p>

<pre>
var k = kaze,
    test = k.test,
    run = k.run;

kaze = k = null;

test("ex:sample a", function (del) {
  return true;
});

test("ex:sample b", function (del) {
  return true;
});

run(function(n, p) {
  alert(n + (p ? " passed" : " failed"));
});
</pre>

<hr>
<p>2010, Eatworms</p>
</body>
</html>
